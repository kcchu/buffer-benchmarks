// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod farcaster {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_TYPE: u16 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_TYPE: u16 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 11] = [
  MessageType::CastAdd,
  MessageType::CastRemove,
  MessageType::ReactionAdd,
  MessageType::ReactionRemove,
  MessageType::AmpAdd,
  MessageType::AmpRemove,
  MessageType::VerificationAddEthAddress,
  MessageType::VerificationRemove,
  MessageType::SignerAdd,
  MessageType::SignerRemove,
  MessageType::UserDataAdd,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageType(pub u16);
#[allow(non_upper_case_globals)]
impl MessageType {
  pub const CastAdd: Self = Self(1);
  pub const CastRemove: Self = Self(2);
  pub const ReactionAdd: Self = Self(3);
  pub const ReactionRemove: Self = Self(4);
  pub const AmpAdd: Self = Self(5);
  pub const AmpRemove: Self = Self(6);
  pub const VerificationAddEthAddress: Self = Self(7);
  pub const VerificationRemove: Self = Self(8);
  pub const SignerAdd: Self = Self(9);
  pub const SignerRemove: Self = Self(10);
  pub const UserDataAdd: Self = Self(11);

  pub const ENUM_MIN: u16 = 1;
  pub const ENUM_MAX: u16 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CastAdd,
    Self::CastRemove,
    Self::ReactionAdd,
    Self::ReactionRemove,
    Self::AmpAdd,
    Self::AmpRemove,
    Self::VerificationAddEthAddress,
    Self::VerificationRemove,
    Self::SignerAdd,
    Self::SignerRemove,
    Self::UserDataAdd,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CastAdd => Some("CastAdd"),
      Self::CastRemove => Some("CastRemove"),
      Self::ReactionAdd => Some("ReactionAdd"),
      Self::ReactionRemove => Some("ReactionRemove"),
      Self::AmpAdd => Some("AmpAdd"),
      Self::AmpRemove => Some("AmpRemove"),
      Self::VerificationAddEthAddress => Some("VerificationAddEthAddress"),
      Self::VerificationRemove => Some("VerificationRemove"),
      Self::SignerAdd => Some("SignerAdd"),
      Self::SignerRemove => Some("SignerRemove"),
      Self::UserDataAdd => Some("UserDataAdd"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessageType {
    type Output = MessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessageType {
  type Scalar = u16;
  #[inline]
  fn to_little_endian(self) -> u16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u16) -> Self {
    let b = u16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SIGNATURE_SCHEME: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SIGNATURE_SCHEME: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SIGNATURE_SCHEME: [SignatureScheme; 2] = [
  SignatureScheme::Ed25519,
  SignatureScheme::Eip712,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SignatureScheme(pub u8);
#[allow(non_upper_case_globals)]
impl SignatureScheme {
  pub const Ed25519: Self = Self(1);
  pub const Eip712: Self = Self(2);

  pub const ENUM_MIN: u8 = 1;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Ed25519,
    Self::Eip712,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Ed25519 => Some("Ed25519"),
      Self::Eip712 => Some("Eip712"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SignatureScheme {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SignatureScheme {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SignatureScheme {
    type Output = SignatureScheme;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SignatureScheme {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SignatureScheme {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SignatureScheme {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HASH_SCHEME: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HASH_SCHEME: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HASH_SCHEME: [HashScheme; 1] = [
  HashScheme::Blake3,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HashScheme(pub u8);
#[allow(non_upper_case_globals)]
impl HashScheme {
  pub const Blake3: Self = Self(1);

  pub const ENUM_MIN: u8 = 1;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Blake3,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Blake3 => Some("Blake3"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for HashScheme {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for HashScheme {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for HashScheme {
    type Output = HashScheme;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HashScheme {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for HashScheme {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for HashScheme {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FARCASTER_NETWORK: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FARCASTER_NETWORK: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FARCASTER_NETWORK: [FarcasterNetwork; 3] = [
  FarcasterNetwork::Mainnet,
  FarcasterNetwork::Testnet,
  FarcasterNetwork::Devnet,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FarcasterNetwork(pub u8);
#[allow(non_upper_case_globals)]
impl FarcasterNetwork {
  pub const Mainnet: Self = Self(1);
  pub const Testnet: Self = Self(2);
  pub const Devnet: Self = Self(3);

  pub const ENUM_MIN: u8 = 1;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Mainnet,
    Self::Testnet,
    Self::Devnet,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Mainnet => Some("Mainnet"),
      Self::Testnet => Some("Testnet"),
      Self::Devnet => Some("Devnet"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FarcasterNetwork {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FarcasterNetwork {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FarcasterNetwork {
    type Output = FarcasterNetwork;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FarcasterNetwork {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FarcasterNetwork {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FarcasterNetwork {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REACTION_TYPE: u16 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REACTION_TYPE: u16 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REACTION_TYPE: [ReactionType; 2] = [
  ReactionType::Like,
  ReactionType::Recast,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReactionType(pub u16);
#[allow(non_upper_case_globals)]
impl ReactionType {
  pub const Like: Self = Self(1);
  pub const Recast: Self = Self(2);

  pub const ENUM_MIN: u16 = 1;
  pub const ENUM_MAX: u16 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Like,
    Self::Recast,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Like => Some("Like"),
      Self::Recast => Some("Recast"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ReactionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ReactionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ReactionType {
    type Output = ReactionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ReactionType {
  type Scalar = u16;
  #[inline]
  fn to_little_endian(self) -> u16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u16) -> Self {
    let b = u16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ReactionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ReactionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_USER_DATA_TYPE: u16 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_USER_DATA_TYPE: u16 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_USER_DATA_TYPE: [UserDataType; 6] = [
  UserDataType::Pfp,
  UserDataType::Display,
  UserDataType::Bio,
  UserDataType::Location,
  UserDataType::Url,
  UserDataType::Fname,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct UserDataType(pub u16);
#[allow(non_upper_case_globals)]
impl UserDataType {
  pub const Pfp: Self = Self(1);
  pub const Display: Self = Self(2);
  pub const Bio: Self = Self(3);
  pub const Location: Self = Self(4);
  pub const Url: Self = Self(5);
  pub const Fname: Self = Self(6);

  pub const ENUM_MIN: u16 = 1;
  pub const ENUM_MAX: u16 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Pfp,
    Self::Display,
    Self::Bio,
    Self::Location,
    Self::Url,
    Self::Fname,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Pfp => Some("Pfp"),
      Self::Display => Some("Display"),
      Self::Bio => Some("Bio"),
      Self::Location => Some("Location"),
      Self::Url => Some("Url"),
      Self::Fname => Some("Fname"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for UserDataType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for UserDataType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u16>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for UserDataType {
    type Output = UserDataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u16>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for UserDataType {
  type Scalar = u16;
  #[inline]
  fn to_little_endian(self) -> u16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u16) -> Self {
    let b = u16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for UserDataType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for UserDataType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TARGET_ID: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TARGET_ID: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TARGET_ID: [TargetId; 2] = [
  TargetId::NONE,
  TargetId::CastId,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TargetId(pub u8);
#[allow(non_upper_case_globals)]
impl TargetId {
  pub const NONE: Self = Self(0);
  pub const CastId: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CastId,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CastId => Some("CastId"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TargetId {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TargetId {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TargetId {
    type Output = TargetId;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TargetId {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TargetId {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TargetId {}
pub struct TargetIdUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_BODY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_BODY: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_BODY: [MessageBody; 9] = [
  MessageBody::NONE,
  MessageBody::CastAddBody,
  MessageBody::CastRemoveBody,
  MessageBody::ReactionBody,
  MessageBody::AmpBody,
  MessageBody::VerificationAddEthAddressBody,
  MessageBody::VerificationRemoveBody,
  MessageBody::SignerBody,
  MessageBody::UserDataBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageBody(pub u8);
#[allow(non_upper_case_globals)]
impl MessageBody {
  pub const NONE: Self = Self(0);
  pub const CastAddBody: Self = Self(1);
  pub const CastRemoveBody: Self = Self(2);
  pub const ReactionBody: Self = Self(3);
  pub const AmpBody: Self = Self(4);
  pub const VerificationAddEthAddressBody: Self = Self(5);
  pub const VerificationRemoveBody: Self = Self(6);
  pub const SignerBody: Self = Self(7);
  pub const UserDataBody: Self = Self(8);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CastAddBody,
    Self::CastRemoveBody,
    Self::ReactionBody,
    Self::AmpBody,
    Self::VerificationAddEthAddressBody,
    Self::VerificationRemoveBody,
    Self::SignerBody,
    Self::UserDataBody,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CastAddBody => Some("CastAddBody"),
      Self::CastRemoveBody => Some("CastRemoveBody"),
      Self::ReactionBody => Some("ReactionBody"),
      Self::AmpBody => Some("AmpBody"),
      Self::VerificationAddEthAddressBody => Some("VerificationAddEthAddressBody"),
      Self::VerificationRemoveBody => Some("VerificationRemoveBody"),
      Self::SignerBody => Some("SignerBody"),
      Self::UserDataBody => Some("UserDataBody"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessageBody {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageBody {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MessageBody {
    type Output = MessageBody;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MessageBody {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageBody {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageBody {}
pub struct MessageBodyUnionTableOffset {}

pub enum CastIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastId<'a> {
  type Inner = CastId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CastId<'a> {
  pub const VT_FID: flatbuffers::VOffsetT = 4;
  pub const VT_TS_HASH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CastId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CastIdArgs<'args>
  ) -> flatbuffers::WIPOffset<CastId<'bldr>> {
    let mut builder = CastIdBuilder::new(_fbb);
    if let Some(x) = args.ts_hash { builder.add_ts_hash(x); }
    if let Some(x) = args.fid { builder.add_fid(x); }
    builder.finish()
  }


  #[inline]
  pub fn fid(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CastId::VT_FID, None).unwrap()}
  }
  #[inline]
  pub fn ts_hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CastId::VT_TS_HASH, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for CastId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("fid", Self::VT_FID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("ts_hash", Self::VT_TS_HASH, true)?
     .finish();
    Ok(())
  }
}
pub struct CastIdArgs<'a> {
    pub fid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub ts_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CastIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    CastIdArgs {
      fid: None, // required field
      ts_hash: None, // required field
    }
  }
}

pub struct CastIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CastIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_fid(&mut self, fid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CastId::VT_FID, fid);
  }
  #[inline]
  pub fn add_ts_hash(&mut self, ts_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CastId::VT_TS_HASH, ts_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CastIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CastId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CastId::VT_FID,"fid");
    self.fbb_.required(o, CastId::VT_TS_HASH,"ts_hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CastId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CastId");
      ds.field("fid", &self.fid());
      ds.field("ts_hash", &self.ts_hash());
      ds.finish()
  }
}
pub enum UserIdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UserId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UserId<'a> {
  type Inner = UserId<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UserId<'a> {
  pub const VT_FID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UserId { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UserIdArgs<'args>
  ) -> flatbuffers::WIPOffset<UserId<'bldr>> {
    let mut builder = UserIdBuilder::new(_fbb);
    if let Some(x) = args.fid { builder.add_fid(x); }
    builder.finish()
  }


  #[inline]
  pub fn fid(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(UserId::VT_FID, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for UserId<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("fid", Self::VT_FID, true)?
     .finish();
    Ok(())
  }
}
pub struct UserIdArgs<'a> {
    pub fid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for UserIdArgs<'a> {
  #[inline]
  fn default() -> Self {
    UserIdArgs {
      fid: None, // required field
    }
  }
}

pub struct UserIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UserIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_fid(&mut self, fid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserId::VT_FID, fid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UserIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UserIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UserId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UserId::VT_FID,"fid");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UserId<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UserId");
      ds.field("fid", &self.fid());
      ds.finish()
  }
}
pub enum CastAddBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastAddBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastAddBody<'a> {
  type Inner = CastAddBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CastAddBody<'a> {
  pub const VT_EMBEDS: flatbuffers::VOffsetT = 4;
  pub const VT_MENTIONS: flatbuffers::VOffsetT = 6;
  pub const VT_PARENT_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_PARENT: flatbuffers::VOffsetT = 10;
  pub const VT_TEXT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CastAddBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CastAddBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<CastAddBody<'bldr>> {
    let mut builder = CastAddBodyBuilder::new(_fbb);
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.parent { builder.add_parent(x); }
    if let Some(x) = args.mentions { builder.add_mentions(x); }
    if let Some(x) = args.embeds { builder.add_embeds(x); }
    builder.add_parent_type(args.parent_type);
    builder.finish()
  }


  #[inline]
  pub fn embeds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CastAddBody::VT_EMBEDS, None)}
  }
  #[inline]
  pub fn mentions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserId<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserId>>>>(CastAddBody::VT_MENTIONS, None)}
  }
  #[inline]
  pub fn parent_type(&self) -> TargetId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TargetId>(CastAddBody::VT_PARENT_TYPE, Some(TargetId::NONE)).unwrap()}
  }
  #[inline]
  pub fn parent(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(CastAddBody::VT_PARENT, None)}
  }
  #[inline]
  pub fn text(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CastAddBody::VT_TEXT, None).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn parent_as_cast_id(&self) -> Option<CastId<'a>> {
    if self.parent_type() == TargetId::CastId {
      self.parent().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CastId::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for CastAddBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("embeds", Self::VT_EMBEDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UserId>>>>("mentions", Self::VT_MENTIONS, false)?
     .visit_union::<TargetId, _>("parent_type", Self::VT_PARENT_TYPE, "parent", Self::VT_PARENT, false, |key, v, pos| {
        match key {
          TargetId::CastId => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastId>>("TargetId::CastId", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, true)?
     .finish();
    Ok(())
  }
}
pub struct CastAddBodyArgs<'a> {
    pub embeds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub mentions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UserId<'a>>>>>,
    pub parent_type: TargetId,
    pub parent: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CastAddBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    CastAddBodyArgs {
      embeds: None,
      mentions: None,
      parent_type: TargetId::NONE,
      parent: None,
      text: None, // required field
    }
  }
}

pub struct CastAddBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CastAddBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_embeds(&mut self, embeds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_EMBEDS, embeds);
  }
  #[inline]
  pub fn add_mentions(&mut self, mentions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UserId<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_MENTIONS, mentions);
  }
  #[inline]
  pub fn add_parent_type(&mut self, parent_type: TargetId) {
    self.fbb_.push_slot::<TargetId>(CastAddBody::VT_PARENT_TYPE, parent_type, TargetId::NONE);
  }
  #[inline]
  pub fn add_parent(&mut self, parent: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_PARENT, parent);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CastAddBody::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastAddBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CastAddBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CastAddBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CastAddBody::VT_TEXT,"text");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CastAddBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CastAddBody");
      ds.field("embeds", &self.embeds());
      ds.field("mentions", &self.mentions());
      ds.field("parent_type", &self.parent_type());
      match self.parent_type() {
        TargetId::CastId => {
          if let Some(x) = self.parent_as_cast_id() {
            ds.field("parent", &x)
          } else {
            ds.field("parent", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("parent", &x)
        },
      };
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum CastRemoveBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastRemoveBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastRemoveBody<'a> {
  type Inner = CastRemoveBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CastRemoveBody<'a> {
  pub const VT_TARGET_TS_HASH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CastRemoveBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CastRemoveBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<CastRemoveBody<'bldr>> {
    let mut builder = CastRemoveBodyBuilder::new(_fbb);
    if let Some(x) = args.target_ts_hash { builder.add_target_ts_hash(x); }
    builder.finish()
  }


  #[inline]
  pub fn target_ts_hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CastRemoveBody::VT_TARGET_TS_HASH, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for CastRemoveBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("target_ts_hash", Self::VT_TARGET_TS_HASH, true)?
     .finish();
    Ok(())
  }
}
pub struct CastRemoveBodyArgs<'a> {
    pub target_ts_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CastRemoveBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    CastRemoveBodyArgs {
      target_ts_hash: None, // required field
    }
  }
}

pub struct CastRemoveBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CastRemoveBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_target_ts_hash(&mut self, target_ts_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CastRemoveBody::VT_TARGET_TS_HASH, target_ts_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastRemoveBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CastRemoveBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CastRemoveBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CastRemoveBody::VT_TARGET_TS_HASH,"target_ts_hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CastRemoveBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CastRemoveBody");
      ds.field("target_ts_hash", &self.target_ts_hash());
      ds.finish()
  }
}
pub enum ReactionBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReactionBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReactionBody<'a> {
  type Inner = ReactionBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReactionBody<'a> {
  pub const VT_TARGET_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReactionBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReactionBodyArgs
  ) -> flatbuffers::WIPOffset<ReactionBody<'bldr>> {
    let mut builder = ReactionBodyBuilder::new(_fbb);
    if let Some(x) = args.target { builder.add_target(x); }
    builder.add_type_(args.type_);
    builder.add_target_type(args.target_type);
    builder.finish()
  }


  #[inline]
  pub fn target_type(&self) -> TargetId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TargetId>(ReactionBody::VT_TARGET_TYPE, Some(TargetId::NONE)).unwrap()}
  }
  #[inline]
  pub fn target(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ReactionBody::VT_TARGET, None).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> ReactionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReactionType>(ReactionBody::VT_TYPE_, Some(ReactionType::Like)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn target_as_cast_id(&self) -> Option<CastId<'a>> {
    if self.target_type() == TargetId::CastId {
      let u = self.target();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CastId::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ReactionBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<TargetId, _>("target_type", Self::VT_TARGET_TYPE, "target", Self::VT_TARGET, true, |key, v, pos| {
        match key {
          TargetId::CastId => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastId>>("TargetId::CastId", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<ReactionType>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct ReactionBodyArgs {
    pub target_type: TargetId,
    pub target: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub type_: ReactionType,
}
impl<'a> Default for ReactionBodyArgs {
  #[inline]
  fn default() -> Self {
    ReactionBodyArgs {
      target_type: TargetId::NONE,
      target: None, // required field
      type_: ReactionType::Like,
    }
  }
}

pub struct ReactionBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReactionBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_target_type(&mut self, target_type: TargetId) {
    self.fbb_.push_slot::<TargetId>(ReactionBody::VT_TARGET_TYPE, target_type, TargetId::NONE);
  }
  #[inline]
  pub fn add_target(&mut self, target: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReactionBody::VT_TARGET, target);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ReactionType) {
    self.fbb_.push_slot::<ReactionType>(ReactionBody::VT_TYPE_, type_, ReactionType::Like);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReactionBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReactionBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReactionBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ReactionBody::VT_TARGET,"target");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReactionBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReactionBody");
      ds.field("target_type", &self.target_type());
      match self.target_type() {
        TargetId::CastId => {
          if let Some(x) = self.target_as_cast_id() {
            ds.field("target", &x)
          } else {
            ds.field("target", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("target", &x)
        },
      };
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum AmpBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AmpBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AmpBody<'a> {
  type Inner = AmpBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AmpBody<'a> {
  pub const VT_USER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AmpBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AmpBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<AmpBody<'bldr>> {
    let mut builder = AmpBodyBuilder::new(_fbb);
    if let Some(x) = args.user { builder.add_user(x); }
    builder.finish()
  }


  #[inline]
  pub fn user(&self) -> UserId<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UserId>>(AmpBody::VT_USER, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for AmpBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<UserId>>("user", Self::VT_USER, true)?
     .finish();
    Ok(())
  }
}
pub struct AmpBodyArgs<'a> {
    pub user: Option<flatbuffers::WIPOffset<UserId<'a>>>,
}
impl<'a> Default for AmpBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    AmpBodyArgs {
      user: None, // required field
    }
  }
}

pub struct AmpBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AmpBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_user(&mut self, user: flatbuffers::WIPOffset<UserId<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UserId>>(AmpBody::VT_USER, user);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AmpBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AmpBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AmpBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, AmpBody::VT_USER,"user");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AmpBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AmpBody");
      ds.field("user", &self.user());
      ds.finish()
  }
}
pub enum VerificationAddEthAddressBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VerificationAddEthAddressBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VerificationAddEthAddressBody<'a> {
  type Inner = VerificationAddEthAddressBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VerificationAddEthAddressBody<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;
  pub const VT_ETH_SIGNATURE: flatbuffers::VOffsetT = 6;
  pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VerificationAddEthAddressBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VerificationAddEthAddressBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<VerificationAddEthAddressBody<'bldr>> {
    let mut builder = VerificationAddEthAddressBodyBuilder::new(_fbb);
    if let Some(x) = args.block_hash { builder.add_block_hash(x); }
    if let Some(x) = args.eth_signature { builder.add_eth_signature(x); }
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn address(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(VerificationAddEthAddressBody::VT_ADDRESS, None).unwrap()}
  }
  #[inline]
  pub fn eth_signature(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(VerificationAddEthAddressBody::VT_ETH_SIGNATURE, None).unwrap()}
  }
  #[inline]
  pub fn block_hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(VerificationAddEthAddressBody::VT_BLOCK_HASH, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for VerificationAddEthAddressBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("address", Self::VT_ADDRESS, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("eth_signature", Self::VT_ETH_SIGNATURE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("block_hash", Self::VT_BLOCK_HASH, true)?
     .finish();
    Ok(())
  }
}
pub struct VerificationAddEthAddressBodyArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub eth_signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for VerificationAddEthAddressBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    VerificationAddEthAddressBodyArgs {
      address: None, // required field
      eth_signature: None, // required field
      block_hash: None, // required field
    }
  }
}

pub struct VerificationAddEthAddressBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VerificationAddEthAddressBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VerificationAddEthAddressBody::VT_ADDRESS, address);
  }
  #[inline]
  pub fn add_eth_signature(&mut self, eth_signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VerificationAddEthAddressBody::VT_ETH_SIGNATURE, eth_signature);
  }
  #[inline]
  pub fn add_block_hash(&mut self, block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VerificationAddEthAddressBody::VT_BLOCK_HASH, block_hash);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VerificationAddEthAddressBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VerificationAddEthAddressBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VerificationAddEthAddressBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, VerificationAddEthAddressBody::VT_ADDRESS,"address");
    self.fbb_.required(o, VerificationAddEthAddressBody::VT_ETH_SIGNATURE,"eth_signature");
    self.fbb_.required(o, VerificationAddEthAddressBody::VT_BLOCK_HASH,"block_hash");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VerificationAddEthAddressBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VerificationAddEthAddressBody");
      ds.field("address", &self.address());
      ds.field("eth_signature", &self.eth_signature());
      ds.field("block_hash", &self.block_hash());
      ds.finish()
  }
}
pub enum VerificationRemoveBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VerificationRemoveBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VerificationRemoveBody<'a> {
  type Inner = VerificationRemoveBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VerificationRemoveBody<'a> {
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VerificationRemoveBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args VerificationRemoveBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<VerificationRemoveBody<'bldr>> {
    let mut builder = VerificationRemoveBodyBuilder::new(_fbb);
    if let Some(x) = args.address { builder.add_address(x); }
    builder.finish()
  }


  #[inline]
  pub fn address(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(VerificationRemoveBody::VT_ADDRESS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for VerificationRemoveBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("address", Self::VT_ADDRESS, true)?
     .finish();
    Ok(())
  }
}
pub struct VerificationRemoveBodyArgs<'a> {
    pub address: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for VerificationRemoveBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    VerificationRemoveBodyArgs {
      address: None, // required field
    }
  }
}

pub struct VerificationRemoveBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VerificationRemoveBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_address(&mut self, address: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VerificationRemoveBody::VT_ADDRESS, address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VerificationRemoveBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VerificationRemoveBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VerificationRemoveBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, VerificationRemoveBody::VT_ADDRESS,"address");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VerificationRemoveBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VerificationRemoveBody");
      ds.field("address", &self.address());
      ds.finish()
  }
}
pub enum SignerBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SignerBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignerBody<'a> {
  type Inner = SignerBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignerBody<'a> {
  pub const VT_SIGNER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignerBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SignerBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<SignerBody<'bldr>> {
    let mut builder = SignerBodyBuilder::new(_fbb);
    if let Some(x) = args.signer { builder.add_signer(x); }
    builder.finish()
  }


  #[inline]
  pub fn signer(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SignerBody::VT_SIGNER, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SignerBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signer", Self::VT_SIGNER, true)?
     .finish();
    Ok(())
  }
}
pub struct SignerBodyArgs<'a> {
    pub signer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SignerBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignerBodyArgs {
      signer: None, // required field
    }
  }
}

pub struct SignerBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SignerBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_signer(&mut self, signer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignerBody::VT_SIGNER, signer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignerBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SignerBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignerBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SignerBody::VT_SIGNER,"signer");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignerBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignerBody");
      ds.field("signer", &self.signer());
      ds.finish()
  }
}
pub enum UserDataBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UserDataBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UserDataBody<'a> {
  type Inner = UserDataBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UserDataBody<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UserDataBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UserDataBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<UserDataBody<'bldr>> {
    let mut builder = UserDataBodyBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> UserDataType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UserDataType>(UserDataBody::VT_TYPE_, Some(UserDataType::Pfp)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UserDataBody::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for UserDataBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<UserDataType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct UserDataBodyArgs<'a> {
    pub type_: UserDataType,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UserDataBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    UserDataBodyArgs {
      type_: UserDataType::Pfp,
      value: None,
    }
  }
}

pub struct UserDataBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UserDataBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: UserDataType) {
    self.fbb_.push_slot::<UserDataType>(UserDataBody::VT_TYPE_, type_, UserDataType::Pfp);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UserDataBody::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UserDataBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UserDataBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UserDataBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UserDataBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UserDataBody");
      ds.field("type_", &self.type_());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum MessageDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MessageData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessageData<'a> {
  type Inner = MessageData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MessageData<'a> {
  pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_BODY: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 10;
  pub const VT_FID: flatbuffers::VOffsetT = 12;
  pub const VT_NETWORK: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MessageData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MessageDataArgs<'args>
  ) -> flatbuffers::WIPOffset<MessageData<'bldr>> {
    let mut builder = MessageDataBuilder::new(_fbb);
    if let Some(x) = args.fid { builder.add_fid(x); }
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.add_network(args.network);
    builder.add_body_type(args.body_type);
    builder.finish()
  }


  #[inline]
  pub fn body_type(&self) -> MessageBody {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageBody>(MessageData::VT_BODY_TYPE, Some(MessageBody::NONE)).unwrap()}
  }
  #[inline]
  pub fn body(&self) -> flatbuffers::Table<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(MessageData::VT_BODY, None).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> Option<MessageType> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageType>(MessageData::VT_TYPE_, None)}
  }
  #[inline]
  pub fn timestamp(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MessageData::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fid(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MessageData::VT_FID, None).unwrap()}
  }
  #[inline]
  pub fn network(&self) -> FarcasterNetwork {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FarcasterNetwork>(MessageData::VT_NETWORK, Some(FarcasterNetwork::Mainnet)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_cast_add_body(&self) -> Option<CastAddBody<'a>> {
    if self.body_type() == MessageBody::CastAddBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CastAddBody::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_cast_remove_body(&self) -> Option<CastRemoveBody<'a>> {
    if self.body_type() == MessageBody::CastRemoveBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { CastRemoveBody::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_reaction_body(&self) -> Option<ReactionBody<'a>> {
    if self.body_type() == MessageBody::ReactionBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { ReactionBody::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_amp_body(&self) -> Option<AmpBody<'a>> {
    if self.body_type() == MessageBody::AmpBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { AmpBody::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_verification_add_eth_address_body(&self) -> Option<VerificationAddEthAddressBody<'a>> {
    if self.body_type() == MessageBody::VerificationAddEthAddressBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VerificationAddEthAddressBody::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_verification_remove_body(&self) -> Option<VerificationRemoveBody<'a>> {
    if self.body_type() == MessageBody::VerificationRemoveBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { VerificationRemoveBody::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_signer_body(&self) -> Option<SignerBody<'a>> {
    if self.body_type() == MessageBody::SignerBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { SignerBody::init_from_table(u) })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_user_data_body(&self) -> Option<UserDataBody<'a>> {
    if self.body_type() == MessageBody::UserDataBody {
      let u = self.body();
      // Safety:
      // Created from a valid Table for this object
      // Which contains a valid union in this slot
      Some(unsafe { UserDataBody::init_from_table(u) })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for MessageData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<MessageBody, _>("body_type", Self::VT_BODY_TYPE, "body", Self::VT_BODY, true, |key, v, pos| {
        match key {
          MessageBody::CastAddBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastAddBody>>("MessageBody::CastAddBody", pos),
          MessageBody::CastRemoveBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastRemoveBody>>("MessageBody::CastRemoveBody", pos),
          MessageBody::ReactionBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReactionBody>>("MessageBody::ReactionBody", pos),
          MessageBody::AmpBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AmpBody>>("MessageBody::AmpBody", pos),
          MessageBody::VerificationAddEthAddressBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VerificationAddEthAddressBody>>("MessageBody::VerificationAddEthAddressBody", pos),
          MessageBody::VerificationRemoveBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VerificationRemoveBody>>("MessageBody::VerificationRemoveBody", pos),
          MessageBody::SignerBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SignerBody>>("MessageBody::SignerBody", pos),
          MessageBody::UserDataBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UserDataBody>>("MessageBody::UserDataBody", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<MessageType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u32>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("fid", Self::VT_FID, true)?
     .visit_field::<FarcasterNetwork>("network", Self::VT_NETWORK, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageDataArgs<'a> {
    pub body_type: MessageBody,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub type_: Option<MessageType>,
    pub timestamp: u32,
    pub fid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub network: FarcasterNetwork,
}
impl<'a> Default for MessageDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessageDataArgs {
      body_type: MessageBody::NONE,
      body: None, // required field
      type_: None,
      timestamp: 0,
      fid: None, // required field
      network: FarcasterNetwork::Mainnet,
    }
  }
}

pub struct MessageDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_body_type(&mut self, body_type: MessageBody) {
    self.fbb_.push_slot::<MessageBody>(MessageData::VT_BODY_TYPE, body_type, MessageBody::NONE);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageData::VT_BODY, body);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: MessageType) {
    self.fbb_.push_slot_always::<MessageType>(MessageData::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u32) {
    self.fbb_.push_slot::<u32>(MessageData::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_fid(&mut self, fid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageData::VT_FID, fid);
  }
  #[inline]
  pub fn add_network(&mut self, network: FarcasterNetwork) {
    self.fbb_.push_slot::<FarcasterNetwork>(MessageData::VT_NETWORK, network, FarcasterNetwork::Mainnet);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessageData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, MessageData::VT_BODY,"body");
    self.fbb_.required(o, MessageData::VT_FID,"fid");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MessageData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MessageData");
      ds.field("body_type", &self.body_type());
      match self.body_type() {
        MessageBody::CastAddBody => {
          if let Some(x) = self.body_as_cast_add_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::CastRemoveBody => {
          if let Some(x) = self.body_as_cast_remove_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::ReactionBody => {
          if let Some(x) = self.body_as_reaction_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::AmpBody => {
          if let Some(x) = self.body_as_amp_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::VerificationAddEthAddressBody => {
          if let Some(x) = self.body_as_verification_add_eth_address_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::VerificationRemoveBody => {
          if let Some(x) = self.body_as_verification_remove_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::SignerBody => {
          if let Some(x) = self.body_as_signer_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageBody::UserDataBody => {
          if let Some(x) = self.body_as_user_data_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("body", &x)
        },
      };
      ds.field("type_", &self.type_());
      ds.field("timestamp", &self.timestamp());
      ds.field("fid", &self.fid());
      ds.field("network", &self.network());
      ds.finish()
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Message<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;
  pub const VT_HASH: flatbuffers::VOffsetT = 6;
  pub const VT_HASH_SCHEME: flatbuffers::VOffsetT = 8;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 10;
  pub const VT_SIGNATURE_SCHEME: flatbuffers::VOffsetT = 12;
  pub const VT_SIGNER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MessageArgs<'args>
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.signer { builder.add_signer(x); }
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.hash { builder.add_hash(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    builder.add_signature_scheme(args.signature_scheme);
    builder.add_hash_scheme(args.hash_scheme);
    builder.finish()
  }


  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Message::VT_DATA, None).unwrap()}
  }
  pub fn data_nested_flatbuffer(&'a self) -> MessageData<'a> {
    let data = self.data();
    use flatbuffers::Follow;
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid flatbuffer in this slot
    unsafe { <flatbuffers::ForwardsUOffset<MessageData<'a>>>::follow(data.bytes(), 0) }
  }
  #[inline]
  pub fn hash(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Message::VT_HASH, None).unwrap()}
  }
  #[inline]
  pub fn hash_scheme(&self) -> HashScheme {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<HashScheme>(Message::VT_HASH_SCHEME, Some(HashScheme::Blake3)).unwrap()}
  }
  #[inline]
  pub fn signature(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Message::VT_SIGNATURE, None).unwrap()}
  }
  #[inline]
  pub fn signature_scheme(&self) -> SignatureScheme {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SignatureScheme>(Message::VT_SIGNATURE_SCHEME, Some(SignatureScheme::Ed25519)).unwrap()}
  }
  #[inline]
  pub fn signer(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Message::VT_SIGNER, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("hash", Self::VT_HASH, true)?
     .visit_field::<HashScheme>("hash_scheme", Self::VT_HASH_SCHEME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, true)?
     .visit_field::<SignatureScheme>("signature_scheme", Self::VT_SIGNATURE_SCHEME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("signer", Self::VT_SIGNER, true)?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub hash_scheme: HashScheme,
    pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub signature_scheme: SignatureScheme,
    pub signer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      data: None, // required field
      hash: None, // required field
      hash_scheme: HashScheme::Blake3,
      signature: None, // required field
      signature_scheme: SignatureScheme::Ed25519,
      signer: None, // required field
    }
  }
}

pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_DATA, data);
  }
  #[inline]
  pub fn add_hash(&mut self, hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_HASH, hash);
  }
  #[inline]
  pub fn add_hash_scheme(&mut self, hash_scheme: HashScheme) {
    self.fbb_.push_slot::<HashScheme>(Message::VT_HASH_SCHEME, hash_scheme, HashScheme::Blake3);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_signature_scheme(&mut self, signature_scheme: SignatureScheme) {
    self.fbb_.push_slot::<SignatureScheme>(Message::VT_SIGNATURE_SCHEME, signature_scheme, SignatureScheme::Ed25519);
  }
  #[inline]
  pub fn add_signer(&mut self, signer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SIGNER, signer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Message::VT_DATA,"data");
    self.fbb_.required(o, Message::VT_HASH,"hash");
    self.fbb_.required(o, Message::VT_SIGNATURE,"signature");
    self.fbb_.required(o, Message::VT_SIGNER,"signer");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("data", &self.data());
      ds.field("hash", &self.hash());
      ds.field("hash_scheme", &self.hash_scheme());
      ds.field("signature", &self.signature());
      ds.field("signature_scheme", &self.signature_scheme());
      ds.field("signer", &self.signer());
      ds.finish()
  }
}
pub enum MessageBytesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MessageBytes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessageBytes<'a> {
  type Inner = MessageBytes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MessageBytes<'a> {
  pub const VT_MESSAGE_BYTES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MessageBytes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MessageBytesArgs<'args>
  ) -> flatbuffers::WIPOffset<MessageBytes<'bldr>> {
    let mut builder = MessageBytesBuilder::new(_fbb);
    if let Some(x) = args.message_bytes { builder.add_message_bytes(x); }
    builder.finish()
  }


  #[inline]
  pub fn message_bytes(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MessageBytes::VT_MESSAGE_BYTES, None).unwrap()}
  }
  pub fn message_bytes_nested_flatbuffer(&'a self) -> Message<'a> {
    let data = self.message_bytes();
    use flatbuffers::Follow;
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid flatbuffer in this slot
    unsafe { <flatbuffers::ForwardsUOffset<Message<'a>>>::follow(data.bytes(), 0) }
  }
}

impl flatbuffers::Verifiable for MessageBytes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("message_bytes", Self::VT_MESSAGE_BYTES, true)?
     .finish();
    Ok(())
  }
}
pub struct MessageBytesArgs<'a> {
    pub message_bytes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MessageBytesArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessageBytesArgs {
      message_bytes: None, // required field
    }
  }
}

pub struct MessageBytesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBytesBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_bytes(&mut self, message_bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessageBytes::VT_MESSAGE_BYTES, message_bytes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBytesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBytesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessageBytes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, MessageBytes::VT_MESSAGE_BYTES,"message_bytes");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MessageBytes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MessageBytes");
      ds.field("message_bytes", &self.message_bytes());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Farcaster

